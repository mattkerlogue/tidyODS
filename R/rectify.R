#' Convert ODS cells to a two-dimensional dataset
#'
#' There are two functions to "rectify" a set of ODS cells extracted by
#' [read_ods_cells()] back into a traditional two-dimensional spreadsheet
#' rectangle.
#'
#' @param ods_cells A set of cells from `read_ods_cells()`.
#' @param base_values Whether to use the `base_value` of a cell (`TRUE`, the
#'   default) or whether to provide the formatted `cell_content`, see
#'  [read_ods_cells()] for further details.
#' @param skip The number of rows to skip before attempting to rectify the cells.
#' @param col_headers Whether to use the first row (after any skipping) as the
#'   column header (`TRUE` is the default), alternatively a character vector of
#'   column names can be provided.
#'
#' @details
#' `simple_rectify()` will perform a basic reshaping of the dataset using either
#' the `base_value` or `cell_content` column of the supplied cells. It also
#' provides options to skip rows and whether to set column headers.
#'
#' `smart_rectify()` performs a more complex reshaping of the dataset, by
#' guessing the location of column headers and using the `value_type` information
#' generated by [read_ods_cells()] to determine whether columns can be coerced
#' to a non-string data type (either numeric, logical, date or time).
#'
#' When set to `TRUE` (the default) the `base_values` argument then the
#' underlying cell values are used. When `FALSE` then cell content as seen by a
#' spreadsheet application user will be shown. See [read_ods_cells()] for further
#' details.
#'
#' If `col_headers = FALSE` or there is otherwise some other issue with
#' obtaining headers from the dataset then they will be are of the format
#' "X#", i.e. "X1", "X2", etc.
#'
#' @return
#' A tibble representing the original spreadsheet format.
#'
#' @examples
#' example <- system.file("extdata", "basic_example.ods", package = "tidyods")
#' example_cells <- read_ods_cells(example, 1)
#' simple_rectify(example_cells, base_values = TRUE)
#' smart_rectify(example_cells)
#' @export
#' @rdname rectify
simple_rectify <- function(ods_cells, skip = 0, col_headers = TRUE,
                           base_values = TRUE) {

  if ("sheet" %in% names(ods_cells)) {
    if(length(unique(ods_cells[["sheet"]])) > 1) {
      cli::cli_abort(
        c(
          x = "More than one sheet present in the cells"
        )
      )
    }
  } else {
    distinct_rc <- dplyr::distinct(ods_cells, row, col)
    if (nrow(distinct_rc) != nrow(ods_cells)) {
      cli::cli_abort(
        c(
          x = "Row/column combinations are duplicated"
        )
      )
    }
  }

  all_cell_positions <- tidyr::crossing(
    row = 1:max(ods_cells$row),
    col = 1:max(ods_cells$col)
  )

  if (base_values) {
    simple_content <- ods_cells %>%
      dplyr::select(row, col, cell_value = base_value)
  } else  {
    simple_content <- ods_cells %>%
      dplyr::select(row, col, cell_content) %>%
      dplyr::mutate(
        cell_value = dplyr::if_else(cell_content == "",
                                    NA_character_,
                                    cell_content)
      ) %>%
      dplyr::select(-cell_content)
  }

  ods_sheet <- all_cell_positions %>%
    dplyr::left_join(simple_content, by = c("row", "col")) %>%
    dplyr::mutate(col = paste0("X", col)) %>%
    tidyr::pivot_wider(names_from = col, values_from = cell_value) %>%
    dplyr::select(-row)

  # handle Excel blank final column if gets past extraction process
  if (sum(is.na(ods_sheet[[ncol(ods_sheet)]])) == nrow(ods_sheet)) {
    ods_sheet <- ods_sheet[, 1:(ncol(ods_sheet) - 1)]
  }

  if (!is.numeric(skip) | length(skip) > 1) {
      cli::cli_abort(c(x = "{.arg skip} must be a numeric vector of length 1"))
  }

  ods_sheet <- ods_sheet[(skip +1):nrow(ods_sheet),]

  if (is.logical(col_headers)) {
    if (col_headers & rowSums(is.na(ods_sheet))[1] > 0) {
      col_headers <- FALSE
      cli::cli_alert_warning(
        "{.arg col_headers} was set to TRUE but row contains missing values"
      )
    }
  }

  if (is.character(col_headers)) {
    if (length(col_headers) != ncol(ods_sheet)) {
      cli::cli_abort(
        c(
          x = "Invalid input for {.arg col_headers}.",
          i = "{.arg col_headers} must be TRUE, FALSE or a character vector.",
          i = "Character vectors must be the same length as the number of columns.",
          i = "There are {ncol(ods_sheet)} columns."
        )
      )
    }

    names(ods_sheet) <- col_headers

  } else if (!is.logical(col_headers)) {
    cli::cli_abort(
      c(
        x = "Invalid input for {.arg col_headers}.",
        i = "{.arg col_headers} must be TRUE, FALSE or a character vector."
      )
    )
  } else if (col_headers) {
    names(ods_sheet) <- ods_sheet[1, ]
    ods_sheet <- ods_sheet[2:nrow(ods_sheet), ]
  }

  return(ods_sheet)

}

quick_rectify <- function(ods_cells) {

  tidyr::crossing(
    row = seq_len(max(ods_cells$row)),
    col = seq_len(max(ods_cells$col)),
  ) |>
    dplyr::left_join(ods_cells, by = c("row", "col")) |>
    dplyr::mutate(col = paste0("x", col)) |>
    dplyr::select(row, col, base_value) |>
    tidyr::pivot_wider(names_from = col, values_from = base_value)

}


#' @export
#' @rdname rectify
smart_rectify <- function(ods_cells) {

  guess_header <- ods_cells %>%
    dplyr::group_by(row) %>%
    dplyr::summarise(empty = sum(is_empty)) %>%
    dplyr::filter(empty == min(empty)) %>%
    dplyr::filter(row == min(row))

  header_full <- guess_header$empty == 0
  header_early <- guess_header$row < 10

  if (header_full & header_early) {
    header_row <- guess_header$row
  } else {
    cli::cli_abort(
      c(
        x = "Unable to guess header row",
        i = "Use {.fun simple_rectify} to coerce {.arg ods_cells} to a sheet"
      )
    )
  }

  col_value_types <- ods_cells %>%
    dplyr::filter(row > header_row) %>%
    dplyr::mutate(
      value_type = dplyr::if_else(
        value_type == "percentage" | value_type == "currency",
        "float",
        value_type)
    ) %>%
    dplyr::group_by(col) %>%
    dplyr::count(value_type) %>%
    dplyr::mutate(prop = n/sum(n)) %>%
    tidyr::drop_na(value_type)

  col_string_info <- ods_cells %>%
    dplyr::filter(row > header_row & value_type == "string") %>%
    dplyr::group_by(col) %>%
    dplyr::summarise(
      string_vals = dplyr::n(),
      unique_strings = length(unique(cell_content)),
      shorthand = sum(cell_content %in% shorthand),
      na_vals = sum(cell_content %in% na_values),
      errors = sum(!is.na(error_type)),
      .groups = "keep"
    ) %>%
    dplyr::mutate(
      strings_all_markers = sum(shorthand, na_vals, errors) == string_vals,
      strings_all_errors = errors == string_vals
    ) %>%
    dplyr::ungroup()

  drop_string <- col_string_info %>%
    dplyr::filter(strings_all_markers & !strings_all_errors) %>%
    dplyr::pull(col)

  dropped_values <- ods_cells %>%
    dplyr::filter(col %in% drop_string &
                    value_type == "string" &
                    row > header_row) %>%
    dplyr::count(col, cell_content)

  col_mutlitype <- col_value_types %>%
    dplyr::filter(!(value_type == "string" & col %in% drop_string)) %>%
    dplyr::count(col) %>%
    dplyr::filter(n > 1) %>%
    dplyr::pull(col)

  col_type_out <- col_value_types %>%
    dplyr::filter(!(value_type == "string" & col %in% drop_string))

  ods_sheet <- simple_rectify(ods_cells, skip = header_row - 1)

  for (i in seq_along(names(ods_sheet))) {

    if (i %in% col_mutlitype) {
      col_type <- "string"
    } else {
      col_type <- col_type_out$value_type[col_type_out$col == i]
    }

    if (length(col_type) == 0) {
      col_type <- "string"
    }

    suppressWarnings(if (col_type == "boolean") {
      ods_sheet[[i]] <- readr::parse_logical(ods_sheet[[i]])
    } else if (col_type == "float") {
      ods_sheet[[i]] <- readr::parse_number(ods_sheet[[i]])
    } else if (col_type == "date") {
      ods_sheet[[i]] <- readr::parse_datetime(ods_sheet[[i]])
    } else if (col_type == "time") {
      ods_sheet[[i]] <- readr::parse_time(
        gsub("^PT|S$", "", gsub("H|M", ":", ods_sheet[[i]]))
      )
    })

  }

  if (nrow(dropped_values) > 0) {
    attr(ods_sheet, "dropped_values") <- dropped_values
    cli::cli_alert_warning(
      "Values dropped from {length(drop_string)} col{?s}, see attribute {.code dropped_values} for details"
    )
  }

  return(ods_sheet)

}

# common shorthand codes
shorthand <- c(
  "b", "c", "e", "er", "f", "low", "p", "r", "u", "w", "x", "z", "ns", "s",
  "ss", "sss",
  "[b]", "[c]", "[e]", "[er]", "[f]", "[low]", "[p]", "[r]", "[u]", "[w]",
  "[x]", "[z]", "[ns]", "[s]", "[ss]", "[sss]",
  "B", "C", "E", "ER", "F", "LOW", "P", "R", "U", "W", "X", "Z", "NS", "S",
  "SS", "SSS",
  "[B]", "[C]", "[E]", "[ER]", "[F]", "[LOW]", "[P]", "[R]", "[U]", "[W]",
  "[X]", "[Z]", "[NS]", "[S]", "[SS]", "[SSS]",
  ".", "..", "...", "....", ":", "-", "--", "---", "–", "—", "~",
  "*", "**", "***", "****", "†", "‡", "§", "‖", "¶", "※", "#", "Δ", "◊"
)

# common na values
na_values <- c(
  "NA", "N/A", "NULL", "na", "n/a", "null"
)
